<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.8.0/styles/default.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.15.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/index.js"></script><script>(r => {
          setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
          const markmap = getMarkmap();
          window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
        })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"<a href=\"https://medium.com/learning-the-go-programming-language/encoding-data-with-the-go-binary-package-42c7c0eb3e73\">Encoding data with Go Binary</a>","children":[{"type":"heading","depth":2,"payload":{"lines":[2,3]},"content":"<a href=\"https://pkg.go.dev/encoding/binary\">encoding/binary Go docs</a>","children":[]},{"type":"heading","depth":2,"payload":{"lines":[4,5]},"content":"<a href=\"https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185\">streaming IO in Go</a>","children":[]},{"type":"heading","depth":2,"payload":{"lines":[6,7]},"content":"<a href=\"https://medium.com/learning-the-go-programming-language/lets-make-an-ntp-client-in-go-287c4b9a969f\">Let's make an NTP client in GO</a>","children":[]},{"type":"heading","depth":2,"payload":{"lines":[8,9]},"content":"<a href=\"https://medium.com/go-walkthrough/go-walkthrough-encoding-binary-96dc5d4abb5d\">Go Walkthrough: encoding/binary</a>","children":[]}]},{"type":"heading","depth":1,"payload":{"lines":[11,12]},"content":"ChatGPT: Binary Protocols","children":[{"type":"heading","depth":2,"payload":{"lines":[12,13]},"content":"Determine the Data Structure:","children":[{"type":"heading","depth":3,"payload":{"lines":[13,14]},"content":"Decide what kind of data you need to transmit or store in your binary protocol. This could be structured data like messages, records, or packets.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[15,16]},"content":"Choose a Schema Definition Language:","children":[{"type":"heading","depth":3,"payload":{"lines":[16,17]},"content":"<strong>Protocol Buffers (ProtoBuf)</strong>: Developed by Google, ProtoBuf is a widely used binary serialization format with its own schema definition language.","children":[]},{"type":"heading","depth":3,"payload":{"lines":[17,18]},"content":"<strong>Apache Avro</strong>: Avro is a binary data format that can be defined using a JSON-based schema language.","children":[]},{"type":"heading","depth":3,"payload":{"lines":[18,19]},"content":"<strong>MessagePack</strong>: MessagePack is a binary serialization format that doesn't have its own schema language, but you can define your schema in JSON or other data definition languages.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[19,20]},"content":"Write the Schema:","children":[{"type":"heading","depth":3,"payload":{"lines":[21,22]},"content":"Use the chosen schema definition language to define your data structure. This typically involves specifying fields, data types, and their order.","children":[]},{"type":"heading","depth":3,"payload":{"lines":[23,24]},"content":"For example, in <strong>Protocol Buffers</strong>, you would write a <code>.proto</code> file to define your message structure.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[24,25]},"content":"Generate Code (Optional):","children":[{"type":"heading","depth":3,"payload":{"lines":[26,27]},"content":"Depending on your chosen schema definition language, you may be able to generate code in different programming languages to serialize and deserialize data based on the schema.","children":[]},{"type":"heading","depth":3,"payload":{"lines":[27,28]},"content":"For example, in <strong>Protocol Buffers</strong>, you can use the <strong>Protocol Buffers</strong> compiler (<code>protoc</code>) to generate code in languages like Go, Python, Java, etc.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"Implement Serialization and Deserialization:","children":[{"type":"heading","depth":3,"payload":{"lines":[30,31]},"content":"Write code in your chosen programming language to serialize data into the binary format defined by your schema and deserialize binary data back into structured data.","children":[]},{"type":"heading","depth":3,"payload":{"lines":[31,32]},"content":"The implementation varies based on the language and libraries you use. If you generated code in Step 4, use the generated code for serialization and deserialization.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[32,33]},"content":"Test and Validate:","children":[{"type":"heading","depth":3,"payload":{"lines":[34,35]},"content":"Test your schema and the serialization/deserialization code to ensure that it correctly encodes and decodes data without loss or corruption.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[35,36]},"content":"Documentation:","children":[{"type":"heading","depth":3,"payload":{"lines":[37,38]},"content":"Document your binary protocol schema so that other developers can understand how to use it.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[38,39]},"content":"Versioning (Optional):","children":[{"type":"heading","depth":3,"payload":{"lines":[40,41]},"content":"Plan for schema evolution and versioning. Schemas may change over time, so it's essential to have a strategy for backward and forward compatibility.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[41,42]},"content":"Choose Appropriate Libraries:","children":[{"type":"heading","depth":3,"payload":{"lines":[43,44]},"content":"Depending on your programming language and protocol, you may need to select suitable libraries or frameworks that support your binary protocol. For instance, if you're using Go, you might use libraries like encoding/binary for low-level binary encoding.","children":[]}]},{"type":"heading","depth":2,"payload":{"lines":[44,45]},"content":"Optimize for Efficiency (Optional):","children":[{"type":"heading","depth":3,"payload":{"lines":[46,47]},"content":"Depending on your use case, you may want to optimize your binary protocol for efficiency in terms of size, parsing speed, or both.","children":[]}]}]},{"type":"heading","depth":1,"payload":{"lines":[49,50]},"content":"Examples:","children":[{"type":"heading","depth":2,"payload":{"lines":[51,52]},"content":"A simple binary Protocol:","children":[{"type":"fence","depth":3,"content":"<pre><code><span class=\"hljs-code\">+----------------+</span>-----------------<span class=\"hljs-code\">+-------------------+</span>\n| Message Length | Message Type    | Message Content   |\n<span class=\"hljs-section\">| (4 bytes)      | (1 byte)        | (variable length) |\n+----------------+-----------------+-------------------+</span>\n</code></pre>\n","children":[],"payload":{"lines":[52,58]}},{"type":"fence","depth":3,"content":"<pre><code class=\"language-golang\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">&quot;bytes&quot;</span>\n    <span class=\"hljs-string\">&quot;encoding/binary&quot;</span>\n    <span class=\"hljs-string\">&quot;fmt&quot;</span>\n    <span class=\"hljs-string\">&quot;log&quot;</span>\n)\n\n<span class=\"hljs-comment\">// Message represents a binary message structure.</span>\n<span class=\"hljs-keyword\">type</span> Message <span class=\"hljs-keyword\">struct</span> {\n    Length  <span class=\"hljs-type\">uint32</span>\n    Type    <span class=\"hljs-type\">byte</span>\n    Content <span class=\"hljs-type\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// Encode a message</span>\n    message := Message{\n        Length:  <span class=\"hljs-number\">19</span>,\n        Type:    <span class=\"hljs-number\">1</span>,\n        Content: <span class=\"hljs-string\">&quot;Hello, Binary Protocol!&quot;</span>,\n    }\n\n    buf := <span class=\"hljs-built_in\">new</span>(bytes.Buffer)\n    <span class=\"hljs-keyword\">if</span> err := binary.Write(buf, binary.LittleEndian, &amp;message.Length); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n    <span class=\"hljs-keyword\">if</span> err := binary.Write(buf, binary.LittleEndian, &amp;message.Type); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n    <span class=\"hljs-keyword\">if</span> err := binary.Write(buf, binary.LittleEndian, []<span class=\"hljs-type\">byte</span>(message.Content)); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n\n    <span class=\"hljs-comment\">// Decode the message</span>\n    <span class=\"hljs-keyword\">var</span> decodedMessage Message\n    <span class=\"hljs-keyword\">if</span> err := binary.Read(buf, binary.LittleEndian, &amp;decodedMessage.Length); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n    <span class=\"hljs-keyword\">if</span> err := binary.Read(buf, binary.LittleEndian, &amp;decodedMessage.Type); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n    contentBytes := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">byte</span>, decodedMessage.Length<span class=\"hljs-number\">-5</span>)\n    <span class=\"hljs-keyword\">if</span> err := binary.Read(buf, binary.LittleEndian, contentBytes); err != <span class=\"hljs-literal\">nil</span> {\n        log.Fatal(err)\n    }\n    decodedMessage.Content = <span class=\"hljs-type\">string</span>(contentBytes)\n\n    <span class=\"hljs-comment\">// Display the original and decoded messages</span>\n    fmt.Printf(<span class=\"hljs-string\">&quot;Original Message: %+v\\n&quot;</span>, message)\n    fmt.Printf(<span class=\"hljs-string\">&quot;Decoded Message: %+v\\n&quot;</span>, decodedMessage)\n}\n\n</code></pre>\n","children":[],"payload":{"lines":[58,114]}}]}]}],"payload":{}},{"colorFreezeLevel":2,"maxWidth":800})</script>
</body>
</html>
